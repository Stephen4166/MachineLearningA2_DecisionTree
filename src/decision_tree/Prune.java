package decision_tree;

import java.util.*;

public class Prune {
//	key: the BFS index of the node, value: the node
	Map<Integer, Node> nodeIndex = new HashMap<Integer, Node> ();
	
//	BFS a tree, and add index for each node
	public int numOrder (Node root) {
		if (!nodeIndex.isEmpty()) {
			nodeIndex.clear();
		}
		
		Queue<Node> queue = new LinkedList<Node> ();
		if ((!root.name.equals("1")) || (!root.name.equals("0"))) {
			queue.add(root);
		}
		int num = 1;
		
		while (!queue.isEmpty()) {
			Node temp = queue.poll();
			temp.index = num;
			nodeIndex.put(num, temp);
			num ++;
			
			if (temp.left != null) {
				if ((!temp.left.name.equals("1")) || (!temp.left.name.equals("0"))) {
					queue.add(temp.left);
				} 
			}
			if (temp.right != null) {
				if ((!temp.right.name.equals("1")) || (!temp.right.name.equals("0"))) {
					queue.add(temp.right);
				} 
			}
		}
		
		return num-1;
	}
	
//	input a dataSet and a root of a tree, output the accuracy
	public double getAccuracy (List<Instance> dataSet, Node root) {
		int total = dataSet.size();
		int correct = 0;
		for (Instance i : dataSet) {
			if (getClass(i, root) == i.ins[i.ins.length-1]) {
				correct ++;
			}
		}
		
		if (dataSet.size() == 0) {
			System.out.println("Error!");
			return -1;
		}
		return (double)correct / (double)total;
	}
	
//	input an instance and a root of a decision tree, get the class generated by the tree
	public boolean getClass (Instance instance, Node root) {
		if (root.name == "1") {
			return true;
		}
		if (root.name == "0") {
			return false;
		}
		if (instance.ins[AttrNameMap.attrMap.get(root.name)]) {
			return getClass (instance, root.left);
		} else {
			return getClass (instance, root.right);
		}
	}
	
//	Given a pruned tree, find out where is the node with null name value
	public Node getNullNode (Instance instance, Node root) {
		if (root.name == "1") {
			return null;
		}
		if (root.name == "0") {
			return null;
		}
		if (root.name == null) {
			return root;
		}
		if (instance.ins[AttrNameMap.attrMap.get(root.name)] == true) {
			return getNullNode (instance, root.left);
		} else {
			return getNullNode (instance, root.right);
		}
	}
	
//	Given a pruned tree, make it a full tree with the validataion_set.csv
	public Node newTree (Node root, List<Instance> dataSet) {
		Set<Node> nullNodeList = new HashSet<Node> ();
		for (Instance i : dataSet) {
			Node nullNode = getNullNode (i, root);
			if (nullNode != null) {
				if (i.ins[i.ins.length-1]) {
					nullNode.posi ++;
					nullNodeList.add(nullNode);
				} else {
					nullNode.nega ++;
					nullNodeList.add(nullNode);
				}
			}
		}
		
		for (Node temp : nullNodeList) {
			if (temp.posi >= temp.nega) {
				temp.name = "1";
			} else {
				temp.name = "0";
			}
		}
		
		return root;
	}
	
//	prune, output the root of the pruned decision tree
	//public Node prune (Node root, List<Instance> dataSet, int pruneNum, int maxShot) {
	public Node prune (Node root, List<Instance> dataSet, String pruneFactStr, int maxShot) {
		double pruneFact = Double.parseDouble(pruneFactStr);
		double oldAccuracy = getAccuracy (dataSet, root);
		double size = (double) dataSet.size();
		double dpruneNum = size * pruneFact;
		int pruneNum = (int) dpruneNum;
		Node temp = Tree.clone(root);
		int max = numOrder (temp);
		List<Integer> numbers = new ArrayList<Integer> ();
		for (int i=1; i<=max; i++) {
			numbers.add(i);
		}
		Collections.shuffle(numbers);
	
		for (int i=0; i<pruneNum; i++) {
			Node k = nodeIndex.get(numbers.get(i));
			k.name = null;
			k.left = null;
			k.right = null;
		}
		
		int count = 0;
		Node _newTree = newTree (temp, dataSet);
		while (getAccuracy (dataSet, _newTree) <= oldAccuracy) {
			temp = Tree.clone(root);
			max = numOrder (temp);
			Collections.shuffle(numbers);
			
			for (int i=0; i<pruneNum; i++) {
				Node k = nodeIndex.get(numbers.get(i));
				k.name = null;
				k.left = null;
				k.right = null;
			}
			_newTree = newTree (temp, dataSet);
			
			count ++;
			if (count > maxShot) {
				break;
			}
		}
		
		if (getAccuracy (dataSet, _newTree) > oldAccuracy) {
			return _newTree;
		} else {
			return root;
		}
		
	}
}